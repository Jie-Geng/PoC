#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Implementation of WinboxMessage class developed by "Copyright 2018-2019 Tenable, Inc."
# https://github.com/tenable/routeros/blob/master/common/winbox_message.hpp,
#
# (C) 2019 Geng Jie <gengjie94@gmail.com>
#

import struct


class WinboxMessage:
    """
    A python implementation of the RouterOS nv::Message.

    This object represents the RouterOS nv::Message. It can parse in a message in
    the binary format (winbox). It can also serialize the message into the binary format.

    Serialization and parsing of JSON format is not implemented yet.
    """

    # variable type
    variable_type = {
        "k_bool": 0,
        "k_short_length": 0x01000000,
        "k_u32": 0x08000000,
        "k_u64": 0x10000000,
        "k_ip6": 0x18000000,
        "k_string": 0x20000000,
        "k_message": 0x28000000,
        "k_raw": 0x30000000,
        "k_bool_array": 0x80000000,
        "k_u32_array": 0x88000000,
        "k_u64_array": 0x90000000,
        "k_ip6_array": 0x98000000,
        "k_string_array": 0xa0000000,
        "k_message_array": 0xa8000000,
        "k_raw_array": 0xb0000000
    }

    # variable names
    variable_names = {
        "k_sys_to": 0x00ff0001,
        "k_from": 0x00ff0002,
        "k_reply_expected": 0x00ff0005,
        "k_request_id": 0x00ff0006,
        "k_command": 0x00ff0007,
        "k_error_code": 0x00ff0008,
        "k_error_string": 0x00ff0009,
        "k_session_id": 0x00fe0001
    }

    # error codes
    error_codes = {
        "k_not_implemented": 0x00fe0002,
        "k_not_implementedv2": 0x00fe0003,
        "k_obj_nonexistant": 0x00fe0004,
        "k_not_permitted": 0x00fe0009,
        "k_timeout": 0x00fe000d,
        "k_obj_nonexistant2": 0x00fe0011,
        "k_busy": 0x00fe0012
    }

    def __init__(self):
        self.m_bools = {}
        self.m_u32s = {}
        self.m_u64s = {}
        self.m_ip6s = {}
        self.m_strings = {}
        self.m_msgs = {}
        self.m_raw = {}
        self.m_bool_array = {}
        self.m_u32_array = {}
        self.m_u64_array = {}
        self.m_ip6_array = {}
        self.m_string_array = {}
        self.m_msg_array = {}
        self.m_raw_array = {}

    def __str__(self):
        ret = "WinboxMessage:\n"
        ret += "-> m_bools:" + str(self.m_bools) + "\n"
        ret += "-> m_u32s:" + str(self.m_u32s) + "\n"
        ret += "-> m_u64s:" + str(self.m_u64s) + "\n"
        ret += "-> m_ip6s:" + str(self.m_ip6s) + "\n"
        ret += "-> m_strings:" + str(self.m_strings) + "\n"
        ret += "-> m_msgs:" + str(self.m_msgs) + "\n"
        ret += "-> m_raw:" + str(self.m_raw) + "\n"
        ret += "-> m_bool_array:" + str(self.m_bool_array) + "\n"
        ret += "-> m_u32_array:" + str(self.m_u32_array) + "\n"
        ret += "-> m_u64_array:" + str(self.m_u64_array) + "\n"
        ret += "-> m_ip6_array:" + str(self.m_ip6_array) + "\n"
        ret += "-> m_string_array:" + str(self.m_string_array) + "\n"
        ret += "-> m_msg_array:" + str(self.m_msg_array) + "\n"
        ret += "-> m_raw_array:" + str(self.m_raw_array) + "\n"
        return ret

    def __repr__(self):
        print("WinboxMessage:")
        print("-> m_bools:", self.m_bools)
        print("-> m_u32s:", self.m_u32s)
        print("-> m_u64s:", self.m_u64s)
        print("-> m_ip6s:", self.m_ip6s)
        print("-> m_strings:", self.m_strings)
        print("-> m_raw:", self.m_raw)
        print("-> m_bool_array:", self.m_bool_array)
        print("-> m_u32_array:", self.m_u32_array)
        print("-> m_u64_array:", self.m_u64_array)
        print("-> m_ip6_array:", self.m_ip6_array)
        print("-> m_string_array:", self.m_string_array)
        print("-> m_msg_array:", self.m_msg_array)
        print("-> m_raw_array:", self.m_raw_array)

    def reset(self):
        """
        Clears all the member variables.
        Effectively returns the object to the default constructor state.

        :return: Nothing
        """
        self.m_bools = {}
        self.m_u32s = {}
        self.m_u64s = {}
        self.m_ip6s = {}
        self.m_strings = {}
        self.m_msgs = {}
        self.m_raw = {}
        self.m_bool_array = {}
        self.m_u32_array = {}
        self.m_u64_array = {}
        self.m_ip6_array = {}
        self.m_string_array = {}
        self.m_msg_array = {}
        self.m_raw_array = {}

    def serialize_to_binary(self):
        """
        Converts the object into a binary format for network communication.
        :return: the binary representation of the data
        """
        return_val = b''

        # As std::map stores its elements in a sorted order,
        # we should sort the dictionary.

        # m_bools
        for name in sorted(self.m_bools):
            type_ = name
            val = self.m_bools[name]  # As k_bool = 0, we don't need the bitwise OR

            if val:
                type_ |= self.variable_type["k_short_length"]  # 1 byte element

            return_val += struct.pack("I", type_)  # boost::uint32_t = 4 bytes

        # m_u32s
        for name in sorted(self.m_u32s):
            type_ = self.variable_type["k_u32"] | name
            val = self.m_u32s[name]

            if val > 255:
                # more than 2 byte length is stored in 4 bytes
                return_val += struct.pack("I", type_)  # boost::uint32_t = 4 bytes
                return_val += struct.pack("I", val)  # boost::uint32_t = 4 bytes
            else:
                # 1byte length is stored in 1 byte
                type_ |= self.variable_type["k_short_length"]  # 1 byte element
                return_val += struct.pack("I", type_)  # boost::uint32_t = 4 bytes
                return_val += struct.pack("B", (val & 0xff))  # 1 byte

        # m_u64s
        for name in sorted(self.m_u64s):
            type_ = self.variable_type["k_u64"] | name
            val = self.m_u64s[name]

            return_val += struct.pack("I", type_)  # boost::uint32_t = 4 bytes
            return_val += struct.pack("Q", val)  # boost::uint64_t = 8 bytes

        # m_ip6s (16-sized byte arrays)
        for name in sorted(self.m_ip6s):
            val = self.m_ip6s[name]
            type_ = self.variable_type["k_ip6"] | name
            return_val += struct.pack("I", type_)  # boost::uint32_t = 4 bytes
            return_val += val  # ip6 is 16-sized bytes array, needless to convert into bytes array

        # m_strings
        for name in sorted(self.m_strings):
            type_ = self.variable_type["k_string"] | name
            val = self.m_strings[name]

            length = len(val)

            if length > 255:
                # when the string length is more than 255, it is stored in 2 bytes.
                return_val += struct.pack("I", type_)  # boost::uint32_t = 4 bytes
                return_val += struct.pack("H", length)  # boost::uint16_t = 2 bytes
            else:
                type_ |= self.variable_type["k_short_length"]
                return_val += struct.pack("I", type_)  # boost::uint32_t = 4 bytes
                return_val += struct.pack("B", length)  # 1 byte

            return_val += val.encode()  # the whole string, need to be converted into bytes array

        # m_msgs
        for name in sorted(self.m_msgs):
            val = self.m_msgs[name]
            type_ = self.variable_type["k_message"] | name

            sub_msg = b'M2' + val.serialize_to_binary()  # As val is a WinboxMessage, we need a recursion
            length = len(sub_msg)

            if length > 255:
                return_val += struct.pack("I", type_)  # boost::uint32_t = 4 bytes
                return_val += struct.pack("H", length)  # boost::uint16_t = 2 bytes
            else:
                type_ |= self.variable_type["k_short_length"]
                return_val += struct.pack("I", type_)  # boost::uint32_t = 4 bytes
                return_val += struct.pack("B", length)  # boost::uint8_t = 1 byte

            return_val += sub_msg

        # m_raw
        for name in sorted(self.m_raw):
            type_ = self.variable_type["k_raw"] | name
            val = self.m_raw[name]

            length = len(val)

            if length > 255:
                return_val += struct.pack("I", type_)  # boost::uint32_t = 4 bytes
                return_val += struct.pack("H", length)  # boost::uint16_t = 2 bytes
            else:
                type_ |= self.variable_type["k_short_length"]
                return_val += struct.pack("I", type_)  # boost::uint32_t = 4 bytes
                return_val += struct.pack("B", length)  # boost::uint8_t = 1 byte

            if isinstance(val, str):
                return_val += val.encode()
            else:
                return_val += val

        # m_bool_array
        for name in sorted(self.m_bool_array):
            val_array = self.m_bool_array[name]
            type_ = self.variable_type["k_bool_array"] | name
            array_size = len(val_array)

            return_val += struct.pack("I", type_)  # boost::uint32_t = 4 bytes
            return_val += struct.pack("H", array_size)  # boost::uint16_t = 2 bytes
            for val in val_array:
                return_val += struct.pack("B", val)  # char

        # m_u32_array
        for name in sorted(self.m_u32_array):
            type_ = self.variable_type["k_u32_array"] | name
            val_array = self.m_u32_array[name]

            array_size = len(val_array)

            return_val += struct.pack("I", type_)  # boost::uint32_t = 4 bytes
            return_val += struct.pack("H", array_size)  # boost::uint16_t = 2 bytes

            for val in val_array:
                return_val += struct.pack("I", val)  # boost::uint32_t = 4 bytes

        # m_u64_array
        for name in sorted(self.m_u64_array):
            type_ = self.variable_type["k_u64_array"] | name
            val_array = self.m_u64_array[name]

            array_size = len(val_array)

            return_val += struct.pack("I", type_)  # boost::uint32_t = 4 bytes
            return_val += struct.pack("H", array_size)  # boost::uint16_t = 2 bytes

            for val in val_array:
                return_val += struct.pack("Q", val)  # boost::uint64_t = 8 bytes

        # m_ip6_array
        for name in sorted(self.m_ip6_array):
            type_ = self.variable_type["k_ip6_array"] | name
            val_array = self.m_ip6_array[name]

            array_size = len(val_array)

            return_val += struct.pack("I", type_)  # boost::uint32_t = 4 bytes
            return_val += struct.pack("H", array_size)  # boost::uint16_t = 2 bytes

            for val in val_array:
                return_val += val  # bytes array itself

        # m_string_array
        for name in sorted(self.m_string_array):
            val_array = self.m_string_array[name]
            type_ = self.variable_type["k_string_array"] | name

            array_size = len(val_array)

            return_val += struct.pack("I", type_)  # boost::uint32_t = 4 bytes
            return_val += struct.pack("H", array_size)  # boost::uint16_t = 2 bytes

            for val in val_array:
                string_size = len(val)
                return_val += struct.pack("H", string_size)  # boost::uint16_t = 2 bytes
                return_val += val.encode()

        # m_msg_array
        for name in sorted(self.m_msg_array):
            val_array = self.m_msg_array[name]
            type_ = self.variable_type["k_message_array"] | name

            array_size = len(val_array)

            return_val += struct.pack("I", type_)  # boost::uint32_t = 4 bytes
            return_val += struct.pack("H", array_size)  # boost::uint16_t = 2 bytes

            for val in val_array:
                sub_msg = b'M2' + val.serialize_to_binary()  # As val is a WinboxMessage, we need a recursion
                length = len(sub_msg)

                return_val += struct.pack("H", length)  # boost::uint16_t = 2 bytes
                return_val += sub_msg

        # m_raw_array
        for name in sorted(self.m_raw_array):
            val_array = self.m_raw_array[name]
            type_ = self.variable_type["k_raw_array"] | name

            array_size = len(val_array)

            return_val += struct.pack("I", type_)  # boost::uint32_t = 4 bytes
            return_val += struct.pack("H", array_size)  # boost::uint16_t = 2 bytes

            for val in val_array:
                string_size = len(val)
                return_val += struct.pack("H", string_size)  # boost::uint16_t = 2 bytes
                return_val += val  # not need to encode

        return return_val

    def parse_binary(self, input_data):
        """
        Parses a binary WinboxMessage
        Parses the provided data and stores the results in member variables.

        Note: This is vulnerable to a stack overflow due to recursion within
              message variables. The irony is that I reported that exact bug
              to Mikrotik. However, I currently have no plans to alter the
              implementation.

        :param input_data: the data to convert into a WinboxMessage
        :return: true if successful and false otherwise
        """

        parse_data = input_data

        # if this starts out with M2 then the caller didn't trim the lead
        # in M2 header. That's fine, just erase it.
        if len(parse_data) > 2 and parse_data[:2] == b'M2':
            parse_data = parse_data[2:]

        while len(parse_data) > 4:
            type_name = struct.unpack("I", parse_data[:4])
            type_name = type_name[0]  # struct.unpack() function returns a tuple
            type_ = type_name & 0xf8000000
            name = type_name & 0x00ffffff
            parse_data = parse_data[4:]

            if type_ == self.variable_type["k_bool"]:
                self.m_bools[name] = (type_name & self.variable_type["k_short_length"]) != 0

            elif type_ == self.variable_type["k_u32"]:
                if type_name & self.variable_type["k_short_length"]:
                    self.m_u32s[name] = parse_data[0]
                    parse_data = parse_data[1:]
                elif len(parse_data) >= 4:
                    val = struct.unpack("I", parse_data[:4])
                    self.m_u32s[name] = val[0]
                    parse_data = parse_data[4:]

            elif type_ == self.variable_type["k_u64"]:
                if len(parse_data) >= 8:
                    val = struct.unpack("Q", parse_data[:8])
                    self.m_u64s[name] = val[0]
                    parse_data = parse_data[8:]

            elif type_ == self.variable_type["k_ip6"]:
                if len(parse_data) >= 16:
                    self.m_ip6s[name] = parse_data[:16]
                    parse_data = parse_data[16:]

            elif type_ == self.variable_type["k_raw"] or type_ == self.variable_type["k_string"]:
                if len(parse_data) >= 2:
                    # get length
                    if type_name & self.variable_type["k_short_length"]:
                        length = parse_data[0]
                        parse_data = parse_data[1:]
                    else:
                        length = struct.unpack("H", parse_data[:2])
                        length = length[0]  # struct.unpack() returns a tuple
                        parse_data = parse_data[2:]

                    # get value
                    if len(parse_data) > length:
                        byte_array = parse_data[:length]
                        if type_ == self.variable_type["k_raw"]:
                            self.m_raw[name] = byte_array
                        else:
                            self.m_strings[name] = byte_array
                        parse_data = parse_data[length:]
                    else:
                        # its hard to account for the weird separators that
                        # MT has inserted mid message.Just mark the entire
                        # remaining message as raw and get on with life
                        if type_ == self.variable_type["k_raw"]:
                            self.m_raw[name] = parse_data
                        else:
                            self.m_strings[name] = parse_data.decode()

                        parse_data = b''
            elif type_ == self.variable_type["k_message"]:
                if len(parse_data) >= 2:

                    # get length
                    if type_name & self.variable_type["k_short_length"]:
                        length = parse_data[0]
                        parse_data = parse_data[1:]
                    else:
                        length = struct.unpack("H", parse_data[:2])
                        length = length[0]  # struct.unpack() returns a tuple
                        parse_data = parse_data[2:]

                    # get value
                    if len(parse_data) >= length:
                        msg_data = parse_data[:length]
                        if len(msg_data) > 2 and msg_data[:2] == b'M2':
                            temp_msg = WinboxMessage()
                            temp_msg.parse_binary(msg_data)
                            self.m_msgs[name] = temp_msg
                            parse_data = parse_data[length:]
                        elif len(parse_data) > 2 and parse_data[:2] == b'M2':
                            # its hard to account for the weird separators that
                            # MT has inserted mid message.Just mark the entire
                            # remaining message as raw and get on with life
                            temp_msg = WinboxMessage()
                            temp_msg.parse_binary(parse_data)
                            self.m_msgs[name] = temp_msg
                            parse_data = b''

            elif type_ == self.variable_type["k_bool_array"]:
                if len(parse_data) >= 2:
                    length = struct.unpack("H", parse_data[:2])
                    length = length[0]  # struct.unpack() returns a tuple
                    parse_data = parse_data[2:]

                    if len(parse_data) < length:
                        length = len(parse_data)

                    bools = []
                    for i in range(length):
                        bools.append(parse_data[i] != 0)
                    self.m_bool_array[name] = bools

                    parse_data = parse_data[length:]

            elif type_ == self.variable_type["k_u32_array"]:
                if len(parse_data) >= 2:
                    length = struct.unpack("H", parse_data[:2])
                    length = length[0]  # struct.unpack() returns a tuple
                    parse_data = parse_data[2:]

                    u32s = []
                    for i in range(length):
                        if len(parse_data) < 4:
                            break
                        u32 = struct.unpack("I", parse_data[:4])
                        u32s.append(u32[0])
                        parse_data = parse_data[4:]

                    self.m_u32_array[name] = u32s

                elif type_ == self.variable_type["k_u64_array"]:
                    if len(parse_data) >= 2:
                        length = struct.unpack("H", parse_data[:2])
                        length = length[0]  # struct.unpack() returns a tuple
                        parse_data = parse_data[2:]

                        u64s = []
                        for i in range(length):
                            if len(parse_data) < 8:
                                break
                            u64 = struct.unpack("Q", parse_data[:8])
                            u64s.append(u64[0])
                            parse_data = parse_data[8:]

                        self.m_u64_array[name] = u64s

                elif type_ == self.variable_type["k_ip6_array"]:
                    if len(parse_data) >= 2:
                        length = struct.unpack("H", parse_data[:2])
                        length = length[0]  # struct.unpack() returns a tuple
                        parse_data = parse_data[2:]

                        ip6s = []
                        for i in range(length):
                            if len(parse_data) < 16:
                                break
                            ip6s.append(parse_data[:16])
                            parse_data = parse_data[16:]

                        self.m_ip6_array[name] = ip6s

                elif type_ == self.variable_type["k_raw_array"] or type_ == self.variable_type["k_string_array"]:
                    if len(parse_data) >= 2:
                        length = struct.unpack("H", parse_data[:2])
                        length = length[0]  # struct.unpack() returns a tuple
                        parse_data = parse_data[2:]

                        arrays = []

                        for i in range(length):
                            if len(parse_data) < 2:
                                break

                            string_length = struct.unpack("H", parse_data[:2])
                            string_length = string_length[0]
                            parse_data = parse_data[2:]

                            if len(parse_data) < string_length:
                                string_length = len(parse_data)

                            if type_ == self.variable_type["k_raw_array"]:
                                arrays.append(parse_data[:string_length])
                            else:
                                arrays.append(parse_data[:string_length].decode())

                            parse_data = parse_data[string_length:]

                        if type_ == self.variable_type["k_raw_array"]:
                            self.m_raw_array[name] = arrays
                        else:
                            self.m_string_array[name] = arrays

                elif type_ == self.variable_type["k_message_array"]:
                    if len(parse_data) >= 2:
                        length = struct.unpack("H", parse_data[:2])
                        length = length[0]  # struct.unpack() returns a tuple
                        parse_data = parse_data[2:]

                        msgs = []

                        for i in range(length):
                            if len(parse_data) < 2:
                                break

                            string_length = struct.unpack("H", parse_data[:2])
                            string_length = string_length[0]
                            parse_data = parse_data[2:]

                            if len(parse_data) < string_length:
                                string_length = len(parse_data)

                            temp_msg = WinboxMessage()
                            temp_msg.parse_binary(parse_data[:string_length])

                            msgs.append(temp_msg)

                            parse_data = parse_data[string_length:]

                        self.m_msg_array[name] = msgs
        return True

    def has_error(self):
        """
        Returns true if an error parameter is present

        :return: true if an error is present. false otherwise.
        """
        return self.variable_names["k_error_string"] in self.m_strings or \
            self.variable_names["k_error_code"] in self.m_u32s

    def get_error_string(self):
        """
        Returns the provided error message or builtin error message corresponding
        to the error number.

        :return: a string indicating the error
        """
        if self.has_error():
            if self.variable_names["k_error_string"] in self.m_strings:
                return self.m_strings[self.variable_names["k_error_string"]]
            elif self.variable_names["k_error_code"] in self.m_u32s:
                error_code = self.m_u32s[self.variable_names["k_error_code"]]
                if error_code == self.error_codes["k_not_implemented"] | \
                        error_code == self.error_codes["k_not_implementedv2"]:
                    return "Feature not implemented"
                elif error_code == self.error_codes["k_obj_nonexistant"] | \
                        error_code == self.error_codes["k_obj_nonexistant2"]:
                    return "Object doesn't exist"
                elif error_code == self.error_codes["k_not_permitted"]:
                    return "Not permitted"
                elif error_code == self.error_codes["k_timeout"]:
                    return "Timeout"
                elif error_code == self.error_codes["k_busy"]:
                    return "Busy"
                else:
                    return "Unknown error code"
        return ""

    def get_session_id(self):
        """
        Returns the session ID.

        :return: (uint32) the session ID
        """
        return self.get_u32(self.variable_names["k_session_id"])

    def set_session_id(self, session_id):
        """
        Sets the messages session ID variable.
        The first message won't need a message ID, but every subsequent message
        does need one. The server will respond with it in the first reply

        :param session_id: The integer representing the session ID
        :return:
        """
        self.add_u32(self.variable_names["k_session_id"], session_id)

    def set_to(self, to, handler):
        """
        Sets the messages "to" variable.
        This controls where the message will be routed to in RouterOS

        :param to: The integer representing the binary to send to
        :param handler: The registered handler that should handle this message
        :return:
        """
        arr = [to, handler]
        self.add_u32_array(self.variable_names["k_sys_to"], arr)

    def set_command(self, command):
        """
        Sets the command variable to the provided value.

        :param command: the command to execute
        :return:
        """
        self.add_u32(self.variable_names["k_command"], command)

    def set_request_id(self, rid):
        """
        Sets the request ID for the message.
        The server will include this ID in the response.

        :param rid: the ID for the request.
        :return:
        """
        self.add_u32(self.variable_names["k_request_id"], rid)

    def set_reply_expected(self, reply_expected):
        """
        Sets the reply expected variable to the provided value.

        :param reply_expected: true if we expect a reply and false otherwise
        :return:
        """
        self.add_bool(self.variable_names["k_reply_expected"], reply_expected)

    def get_bool(self, name):
        """
        Returns the value of a boolean variable.

        :param name: the name of the variable (ie. 0xff0007)
        :return: (boolean) the stored value for the provided variable
        """
        return self.m_bools[name]

    def add_bool(self, name, value):
        """
        Adds a new boolean value to the message

        :param name: the variables name (ie. 0xff0007)
        :param value: p_value the variable's value
        :return:
        """
        self.m_bools[name] = value

    def get_u32(self, name):
        """
        Returns the value of a 32 bit variable.

        :param name: the name of the variable (ie. 0xff0007)
        :return: (uint32) the stored value for the provided variable
        """
        return self.m_u32s[name]

    def add_u32(self, name, value):
        """
        Adds a new 32 bit value to the message

        :param name: the variables name (ie. 0xff0007)
        :param value: the variable's value
        :return:
        """
        self.m_u32s[name] = value

    def get_u64(self, name):
        """
        Returns the value of a 64 bit variable.

        :param name: the name of the variable (ie. 0xff0007)
        :return: (uint64) the stored value for the provided variable
        """
        return self.m_u64s[name]

    def add_u64(self, name, value):
        """
        Adds a new 64 bit value to the message

        :param name: the variables name (ie. 0xff0007)
        :param value: the variable's value
        :return:
        """
        self.m_u64s[name] = value

    def get_ip6(self, name):
        """
        Returns the value of a ip6 variable.

        :param name: the name of the variable (ie. 0xff0007)
        :return: (16-byte byte array) the stored value for the provided variable
        """
        return self.m_ip6s[name]

    def add_ip6(self, name, value):
        """
        Adds a new ip6 value to the message

        :param name: the variables name (ie. 0xff0007)
        :param value: the variable's value
        :return:
        """
        self.m_ip6s[name] = value

    def get_string(self, name):
        """
        Returns the value of a string variable.

        :param name: the name of the variable (ie. 0xff0007)
        :return: (string) the stored value for the provided variable
        """
        return self.m_strings[name]

    def add_string(self, name, value):
        """
        Adds a new string value to the message

        :param name: the variables name (ie. 0xff0007)
        :param value: the variable's value
        :return:
        """
        self.m_strings[name] = value

    def get_raw(self, name):
        """
        Returns the value of a raw variable.

        :param name: the name of the variable (ie. 0xff0007)
        :return: (string) the stored value for the provided variable
        """
        return self.m_raw[name]

    def add_raw(self, name, raw):
        """
        Adds a new raw value to the message

        :param name: the variables name (ie. 0xff0007)
        :param raw: the variable's value
        :return:
        """
        self.m_raw[name] = raw

    def get_message(self, name):
        """
        Returns the value of a WinboxMessage variable.

        :param name: the name of the variable (ie. 0xff0007)
        :return: (WinboxMessage) the stored value for the provided variable
        """
        return self.m_msgs[name]

    def add_message(self, name, raw):
        """
        Adds a new WinboxMessage value to the message

        :param name: the variables name (ie. 0xff0007)
        :param raw: the variable's value
        :return:
        """
        self.m_msgs[name] = raw

    def get_bool_array(self, name):
        """
        Returns the value of a bool array.

        :param name: the name of the variable (ie. 0xff0007)
        :return: (array of byte) the stored value for the provided variable
        """
        return self.m_bool_array[name]

    def add_bool_array(self, name, val):
        """
        Adds a new bool array value to the message

        :param name: the variables name (ie. 0xff0007)
        :param val: the variable's value
        :return:
        """
        self.m_bool_array[name] = val

    def get_u32_array(self, name):
        """
        Returns the value of a uint32 array.

        :param name: the name of the variable (ie. 0xff0007)
        :return: (uint32) the stored value for the provided variable
        """
        return self.m_u32_array[name]

    def add_u32_array(self, name, val):
        """
        Adds a new uint32 array value to the message

        :param name: the variables name (ie. 0xff0007)
        :param val: the variable's value
        :return:
        """
        self.m_u32_array[name] = val

    def get_u64_array(self, name):
        """
        Returns the value of a uint64 array.

        :param name: the name of the variable (ie. 0xff0007)
        :return: (uint64) the stored value for the provided variable
        """
        return self.m_u64_array[name]

    def add_u64_array(self, name, val):
        """
        Adds a new uint64 array value to the message

        :param name: the variables name (ie. 0xff0007)
        :param val: the variable's value
        :return:
        """
        self.m_u64_array[name] = val

    def get_ip6_array(self, name):
        """
        Returns the value of a ip6 array.

        :param name: the name of the variable (ie. 0xff0007)
        :return: (16-byte array) the stored value for the provided variable
        """
        return self.m_ip6_array[name]

    def add_ip6_array(self, name, val):
        """
        Adds a new ip6 array value to the message

        :param name: the variables name (ie. 0xff0007)
        :param val: the variable's value
        :return:
        """
        self.m_ip6_array[name] = val

    def get_string_array(self, name):
        """
        Returns the value of a string array.

        :param name: the name of the variable (ie. 0xff0007)
        :return: (string array) the stored value for the provided variable
        """
        return self.m_string_array[name]

    def add_string_array(self, name, val):
        """
        Adds a new string array value to the message

        :param name: the variables name (ie. 0xff0007)
        :param val: the variable's value
        :return:
        """
        self.m_string_array[name] = val

    def get_raw_array(self, name):
        """
        Returns the value of a raw array.

        :param name: the name of the variable (ie. 0xff0007)
        :return: (raw array) the stored value for the provided variable
        """
        return self.m_raw_array[name]

    def add_raw_array(self, name, val):
        """
        Adds a new raw array value to the message

        :param name: the variables name (ie. 0xff0007)
        :param val: the variable's value
        :return:
        """
        self.m_raw_array[name] = val

    def get_msg_array(self, name):
        """
        Returns the value of a WinboxMessage array.

        :param name: the name of the variable (ie. 0xff0007)
        :return: (WinboxMessage array) the stored value for the provided variable
        """
        return self.m_msg_array[name]

    def add_msg_array(self, name, val):
        """
        Adds a new WinboxMessage array value to the message

        :param name: the variables name (ie. 0xff0007)
        :param val: the variable's value
        :return:
        """
        self.m_msg_array[name] = val
