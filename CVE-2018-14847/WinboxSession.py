#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Implementation of WinboxSession class developed by "Copyright 2018-2019 Tenable, Inc."
# https://github.com/tenable/routeros/blob/master/common/winbox_session.hpp,
#
# (C) 2019 Geng Jie <gengjie94@gmail.com>
#

from WinboxMessage import WinboxMessage
import Config
import socket
import struct
import hashlib


class WinboxSession:

    def __init__(self, ip, port):
        self.ip = ip
        self.port = port
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        except socket.error as err:
            print("Socket creation failed with error %s" % err)

    def connect(self):
        try:
            self.socket.connect((self.ip, self.port))
        except socket.error as err:
            print("Connection to the router failed with error %s" % err)
            return False

        return True

    @staticmethod
    def parse_header(header):
        if len(header) != 4:
            return 0

        short_length = struct.unpack("B", header[:1])
        short_length = short_length[0]

        long_length = struct.unpack("!H", header[2:])
        long_length = long_length[0]

        if short_length == 0xff:
            return long_length

        if (short_length - 2) != long_length:
            print("Length mismatch")
            return 0

        return long_length

    def login(self, username, password, session_id):
        """
        Login to the Mikrotik router. Performs Challenge exchage authentication

        :param username: router user name
        :param password: router user password
        :param session_id: session it to connect
        :return: False if failed, session_id if success
        """

        # request the challenge
        msg = WinboxMessage()
        msg.set_to(13, 4)
        msg.set_command(4)
        msg.set_request_id(2)
        msg.set_session_id(session_id)
        msg.set_reply_expected(True)
        if not self.send(msg):
            return False

        msg = self.receive()
        if not msg or msg.has_error():
            print(msg.get_error_string())
            return False

        salt = msg.get_raw(0x9)
        if len(salt) != 16:
            msg = self.receive()
            if not msg | msg.has_error():
                print(msg.get_error_string())
                return False
            salt = msg.get_raw(0x9)

        # generate the challenge response
        m = hashlib.md5()
        one = b'\x00'
        m.update(one)
        m.update(password.encode())
        m.update(salt)
        hashed = one + m.digest()

        msg.reset()
        msg.set_to(13, 4)
        msg.set_command(1)
        msg.set_request_id(3)
        msg.set_session_id(session_id)
        msg.set_reply_expected(True)
        msg.add_string(1, username)
        msg.add_raw(9, salt)
        msg.add_raw(10, hashed)

        if not self.send(msg):
            return False

        msg = self.receive()
        if not msg:
            print("Error receiving a response.")
            return False

        if msg.has_error():
            print(msg.get_error_string())
            return False

        sess_id = msg.get_session_id()

        return sess_id

    def send(self, msg):
        # serialize the WinboxMessage into a binary data
        serialized = msg.serialize_to_binary()

        # each message starts with M2 (message format 2) identifier
        if serialized[:2] != b'M2':
            serialized = b'M2' + serialized

        if Config.DEBUG:
            print("Sending Data:", end=' ')
            for b in serialized:
                print("{:02X}".format(b), end=' ')
            print()

        serialized_len = len(serialized)
        if serialized_len > 0xffff:
            print("Winbox message over-sized.")
            return False

        msg_size = [(serialized_len >> 8) & 0xff, serialized_len & 0xff]
        buffer = b''

        if serialized_len < 0xfe:
            buffer += struct.pack("B", msg_size[1]+2)
            buffer += b'\x01'

            buffer += struct.pack("B", msg_size[0])
            buffer += struct.pack("B", msg_size[1])

            buffer += serialized
        else:
            buffer += b'\xff\x01'

            buffer += struct.pack("B", msg_size[0])
            buffer += struct.pack("B", msg_size[1])

            buffer += serialized[:0xfd]  # 0xff-2, because we write 2 bytes above
            serialized = serialized[0xfd:]

            while len(serialized) > 0:
                if len(serialized) > 0xff:
                    buffer += b'\xff\xff'
                    buffer += serialized[:0xff]
                    serialized = serialized[0xff:]
                else:
                    remain = len(serialized)
                    buffer += struct.pack("B", remain & 0xff)
                    buffer += b'\xff'
                    buffer += serialized
                    serialized = b''

        if Config.DEBUG:
            print("Sending Data:", end=' ')
            for b in buffer:
                print("{:02X}".format(b), end=' ')
            print()

        try:
            self.socket.sendall(buffer)
        except socket.error as err:
            print("Send message failed with error %s" % err)
            return False

        return True

    def receive(self):
        data = self.socket.recv(4)
        if Config.DEBUG:
            print("Received header:", end=' ')
            for b in data:
                print("{:02x}".format(b), end=' ')
            print()

        to_read = self.parse_header(data)
        if to_read == 0:
            return False

        message = b''

        # reading bulks
        bulk_size = 0xfd
        while to_read > 0xff:
            # read a bulk
            bulk = self.socket.recv(bulk_size)
            message += bulk

            # skip two byte separators of 0xff
            self.socket.recv(2)

            to_read -= bulk_size
            bulk_size = 0xff

        # read remaining contents
        message += self.socket.recv(to_read)

        if Config.DEBUG:
            print("Received body:", end=' ')
            for b in message:
                print("{:02x}".format(b), end=' ')
            print()

        msg = WinboxMessage()
        msg.parse_binary(message)

        if Config.DEBUG:
            print(msg)

        return msg
